#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0

import argparse
import time
from pathlib import Path
from os import readlink

import git
import jinja2
from jinja2 import meta

# The subdirectory of the repo containing zonefile templates
TMPL_DIR = 'templates'

# Header placed on all output zonefiles
HEADER = '''; WARNING!
; This file was automatically generated from a template
; Do NOT edit this file directly!

'''


def parse_args():
    """Sets up argument parser and its arguments, returns args"""
    parser = argparse.ArgumentParser()
    parser.add_argument('zonedir',
                        help='Empty outdir for zones, dry run if not set',
                        nargs='?',
                        default='')
    return parser.parse_args()


def validate_empty_dir(path):
    """Path object must be non-link dir which is empty"""
    if not path.is_symlink() and path.is_dir():
        if len(list(path.iterdir())) == 0:
            return
    raise Exception('%s must be a real empty directory' % path)


def get_template_files(template_env, tmpl_name):
    """Get the full list of files parsed to process this template"""
    raw_src = template_env.loader.get_source(template_env, tmpl_name)[0]
    ast = template_env.parse(raw_src)
    included = meta.find_referenced_templates(ast)
    return list(included) + [tmpl_name]


def ascii_transliterate(text):
    """Transliterate an arbitrary text to printable ASCII using '?' as a replacement character."""
    chars = []
    for c in text:
        if 19 < ord(c) < 128:
            chars.append(c)
        else:
            chars.append('?')

    return ''.join(chars)


def make_serial(repo, template_env, tmpl_name, zname):
    """Make serial from git metadata"""
    flist = get_template_files(template_env, tmpl_name)
    if zname != tmpl_name:
        flist += [zname]
    flist_prefixed = [Path(TMPL_DIR, s) for s in flist]
    # It might be nice to track uncommitted index/workdir changes here too
    try:
        commit = next(repo.iter_commits(max_count=1, paths=flist_prefixed))
        sernum = time.strftime('%Y%m%d%H', time.gmtime(commit.committed_date))
        return sernum, '%s %s %s' % (sernum,
                                     str(commit)[:8],
                                     ascii_transliterate(str(commit.message).splitlines()[0]))
    except StopIteration:
        return 12345, 'Unknown/uncommitted'


def process_tmpl(zname, template_path, repo, template_env, zone_dir):
    """Process a template file from the templates directory"""
    template = template_env.get_template(template_path.name)
    serial_num, serial_comment = make_serial(repo, template_env,
                                             template_path.name, zname)
    output = template.render({
        "serial_num": serial_num,
        "serial_comment": serial_comment,
    })
    if zone_dir:
        Path(zone_dir, zname).write_text(HEADER + output + "\n")


def get_validated_symlink(template_path):
    """Sanitize for simple symlinks to local non-dot files, return dest"""
    # pathlib doesn't do raw readlink, and there's no good way to implement
    # what we're checking here without it:
    dest = Path(readlink(str(template_path)))
    if str(dest) != dest.name:
        raise Exception('%s -> %s : Link dest must stay in same dir'
                        % (template_path.name, dest))
    # Can't link to dot-files, because we skip those for regular processing
    if dest.name.startswith('.'):
        raise Exception('%s -> %s : Link dest cannot be a dot-file'
                        % (template_path.name, dest))
    # Ensure link is to a real file that exists (not double-indirection with
    # another link, not dangling, not to a special/dir, etc)
    tmpl_dest = Path(TMPL_DIR, dest)
    if tmpl_dest.is_symlink() or not tmpl_dest.is_file():
        raise Exception('%s -> %s : Link must be to an existing real file'
                        % (template_path.name, dest))
    return tmpl_dest


def main():
    """main"""
    args = parse_args()

    # Sanity check we're executing in our repo root
    gitr = Path('.gitreview')
    if not gitr.is_file() or 'operations/dns' not in gitr.read_text():
        raise Exception('Execute in root of an operations/dns repo clone')

    zone_dir = None
    if args.zonedir:
        zone_dir = Path(args.zonedir)
        validate_empty_dir(zone_dir)

    # Set up template engine
    template_env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(TMPL_DIR),
        undefined=jinja2.StrictUndefined,
    )

    # Counter is just for the final summary output text
    zcount = 0

    # Repo object for git history access
    repo = git.Repo('.')

    # Iterate templates/ for regular files and links, ignoring dotfiles,
    # directories, and anything else special
    for template_path in Path(TMPL_DIR).iterdir():
        zname = template_path.name
        if zname.startswith('.'):
            continue
        zcount += 1
        if template_path.is_symlink():
            template_path = get_validated_symlink(template_path)
        if template_path.is_file():
            process_tmpl(zname, template_path, repo, template_env, zone_dir)

    if zone_dir:
        action_txt = 'into directory %s' % zone_dir
    else:
        action_txt = 'in dry-run mode'
    print(' -- Processed %d zones %s' % (zcount, action_txt), flush=True)


if __name__ == '__main__':
    main()

# vim: ts=4 sts=4 et ai shiftwidth=4 fileencoding=utf-8
